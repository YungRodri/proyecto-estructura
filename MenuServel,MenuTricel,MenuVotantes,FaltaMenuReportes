 #include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_CANDIDATOS 20
#define IDX_SIN_VOTO   -1

/* Opcional: códigos de ronda/estado si los quieres como int */
#define RONDA_PRIMERA   1
#define RONDA_SEGUNDA   2
#define ELEC_ABIERTA    1
#define ELEC_CERRADA    2
#define ELEC_PROCLAMADA 3
/* ====== Forward declarations (porque hay punteros cruzados) ====== */
struct Candidato;
struct DVotante;
struct NodoMesa;
struct Eleccion;
struct Resultado;
struct Servel;
struct Tricel;
struct SistemaElectoral;

/* ====== Persona ====== */
struct Persona {
    char *rut[20];
    char *nombre[50];
    char *nacionalidad[30];
    int  edad;
};

/* ====== Candidato (pool estático del Servel) ====== */
struct Candidato {
    struct Persona *datos;
    char *partido[40];
    char *tipo[20];     /* "Partido" o "Independiente" */
    int  firmasApoyo;
    int  esValido;     /* 1 si aprobado por Servel  0 Si no es aprobado*/
    int  id;           /* índice dentro del pool */
};

/* ====== Votante (lista DOBLEMENTE enlazada por mesa) ====== */
struct DVotante {
    struct Persona *datos;
    int  habilitado;       /* 1 puede votar */
    int  haVotado;         /* 1 ya votó */
    int  idxCandVoto;      /* 0..nCands-1 dentro de la ELECCIÓN, o IDX_SIN_VOTO */
    struct DVotante *ant;
    struct DVotante *sig;
};

/* ====== Mesa (nodo del ABB de una elección) ====== */
struct NodoMesa {
    int  idMesa;
    char *comuna[40];
    char *direccion[100];

    int  votosCandidatos[MAX_CANDIDATOS]; /* usa 0..(nCands-1) de la elección */
    int  totalVotosEmitidos;
    int  votosBlancos;
    int  votosNulos;

    struct DVotante *headV;  /* lista doble: cabeza */
    struct DVotante *tailV;  /* lista doble: cola   */

    struct NodoMesa *izq;    /* ABB por idMesa */
    struct NodoMesa *der;
};

/* ====== Elección (nodo de LISTA SIMPLE en Servel) ====== */
struct Eleccion {
    int  id;
    int  ronda;    /* RONDA_PRIMERA / RONDA_SEGUNDA */
    int  estado;   /* ELEC_ABIERTA / ELEC_CERRADA / ELEC_PROCLAMADA */
    struct Candidato *cands[MAX_CANDIDATOS]; /* arreglo compacto de punteros */
    int   nCands;                             /* tamaño efectivo del arreglo */
    struct NodoMesa *arbolMesas;              /* ABB propio de esta elección */
    struct Resultado * candidato_En_Resultado;
    struct Eleccion *sig;                     /* siguiente elección (historial) */
};

/* ====== Resultado (nodo de LISTA CIRCULAR en Tricel) ====== */
struct Resultado {
    struct Candidato *ganador;    /* puntero a uno de eleccion->cands[idxGanador] */
    int   totalMesas;
    int   totalVotantesRegistrados;
    int   totalVotantesVotaron;
    int   votosValidos;
    int   votosBlancos;
    int   votosNulos;
    float porcentajeParticipacion;               /* 0..100 */
    float porcentajeCandidato[MAX_CANDIDATOS];   /* solo 0..(nCands-1) */
    int   idxGanador;                            /* índice dentro del arreglo compacto */
    float porcentajeGanador;
    struct Resultado *sig;   /* anillo: lista circular simplemente enlazada */
};

/* ====== Servel: pool de candidatos + LISTA de elecciones ====== */
struct Servel {
    struct Candidato *candidatos[MAX_CANDIDATOS]; /* pool estático */
    int   totalCandidatos;
    struct Eleccion *elecciones;                 /* cabeza de la lista simple */
    int   totalVotantesRegistrados;              /* opcional global */
};

/* ====== Tricel: LISTA CIRCULAR de resultados ====== */
struct Tricel {
    struct Resultado *headResultados;  /* NULL si vacío; si 1 nodo: head->sig == head */
    int   totalResultados;
};

/* ====== Sistema (punteros a módulos en heap) ====== */
struct SistemaElectoral {
    struct Servel *servel;
    struct Tricel *tricel;
};
// agregar datos noma
void inicializarSistemaConDatos(struct SistemaElectoral *sistema)
{
    struct Servel *servel;
    struct Tricel *tricel;
    struct Candidato *c1, *c2;
    struct Persona *p1, *p2;
    struct Eleccion *e1;
    struct NodoMesa *m1;
    struct Resultado *r1;
    int i;

    if (sistema == NULL) {
        printf("ERROR: sistema NULL en inicializarSistemaConDatos.\n");
        return;
    }

    servel = sistema->servel;
    tricel = sistema->tricel;

    if (servel == NULL || tricel == NULL) {
        printf("ERROR: servel/tricel NULL en inicializarSistemaConDatos.\n");
        return;
    }

    /* =========================
       1) CANDIDATOS DE EJEMPLO
       ========================= */

    servel->totalCandidatos = 0;
    servel->elecciones = NULL;
    servel->totalVotantesRegistrados = 0;

    /* ---- Candidato 1 ---- */
    c1 = (struct Candidato *) malloc(sizeof(struct Candidato));
    p1 = (struct Persona  *) malloc(sizeof(struct Persona));

    if (c1 == NULL || p1 == NULL) {
        printf("Error de memoria creando candidato 1.\n");
        return;
    }

    c1->datos = p1;

    /* reservar cadenas índice 0 */
    p1->rut[0]          = (char *) malloc(12 * sizeof(char));
    p1->nombre[0]       = (char *) malloc(50 * sizeof(char));
    p1->nacionalidad[0] = (char *) malloc(30 * sizeof(char));
    c1->partido[0]      = (char *) malloc(40 * sizeof(char));
    c1->tipo[0]         = (char *) malloc(20 * sizeof(char));

    /* set de ejemplo */
    strcpy(p1->rut[0],          "11111111");
    strcpy(p1->nombre[0],       "Alice");
    strcpy(p1->nacionalidad[0], "chilena");
    p1->edad = 45;
    strcpy(c1->partido[0],      "PartidoX");
    strcpy(c1->tipo[0],         "partido");
    c1->firmasApoyo = 0;
    c1->id          = 0;
    c1->esValido    = validarDatosCanditado(c1);  /* usa tu función */

    servel->candidatos[servel->totalCandidatos] = c1;
    servel->totalCandidatos++;

    /* ---- Candidato 2 ---- */
    c2 = (struct Candidato *) malloc(sizeof(struct Candidato));
    p2 = (struct Persona  *) malloc(sizeof(struct Persona));

    if (c2 == NULL || p2 == NULL) {
        printf("Error de memoria creando candidato 2.\n");
        return;
    }

    c2->datos = p2;

    p2->rut[0]          = (char *) malloc(12 * sizeof(char));
    p2->nombre[0]       = (char *) malloc(50 * sizeof(char));
    p2->nacionalidad[0] = (char *) malloc(30 * sizeof(char));
    c2->partido[0]      = (char *) malloc(40 * sizeof(char));
    c2->tipo[0]         = (char *) malloc(20 * sizeof(char));

    strcpy(p2->rut[0],          "22222222");
    strcpy(p2->nombre[0],       "Bob");
    strcpy(p2->nacionalidad[0], "chilena");
    p2->edad = 50;
    strcpy(c2->partido[0],      "PartidoY");
    strcpy(c2->tipo[0],         "independiente");
    c2->firmasApoyo = 120000;   /* para que cumpla reglas de independiente */
    c2->id          = 1;
    c2->esValido    = validarDatosCanditado(c2);

    servel->candidatos[servel->totalCandidatos] = c2;
    servel->totalCandidatos++;

    /* =====================
       2) ELECCION DE EJEMPLO
       ===================== */

    e1 = (struct Eleccion *) malloc(sizeof(struct Eleccion));
    if (e1 == NULL) {
        printf("Error de memoria creando eleccion.\n");
        return;
    }

    e1->id     = 100;
    e1->ronda  = RONDA_PRIMERA;
    e1->estado = ELEC_ABIERTA;
    e1->nCands = 0;

    for (i = 0; i < MAX_CANDIDATOS; i++) {
        e1->cands[i] = NULL;
    }

    /* asociar algunos candidatos validos a la eleccion */
    e1->cands[e1->nCands++] = c1;
    e1->cands[e1->nCands++] = c2;

    e1->arbolMesas = NULL;
    e1->candidato_En_Resultado = NULL;
    e1->sig = NULL;

    /* insertar la eleccion al inicio del historial del servel */
    e1->sig = servel->elecciones;
    servel->elecciones = e1;

    /* ==========================
       3) MESA DE EJEMPLO (ABB)
       ========================== */

    m1 = (struct NodoMesa *) malloc(sizeof(struct NodoMesa));
    if (m1 == NULL) {
        printf("Error de memoria creando mesa.\n");
        return;
    }

    m1->idMesa = 10;

    m1->comuna[0]    = (char *) malloc(40 * sizeof(char));
    m1->direccion[0] = (char *) malloc(100 * sizeof(char));

    strcpy(m1->comuna[0],    "SanFelipe");
    strcpy(m1->direccion[0], "ColegioCentral123");

    for (i = 0; i < MAX_CANDIDATOS; i++) {
        m1->votosCandidatos[i] = 0;
    }
    m1->totalVotosEmitidos = 0;
    m1->votosBlancos       = 0;
    m1->votosNulos         = 0;
    m1->headV              = NULL;
    m1->tailV              = NULL;
    m1->izq                = NULL;
    m1->der                = NULL;

    /* esta eleccion tiene un ABB con solo esta mesa */
    e1->arbolMesas = m1;

    /* ==========================
       4) RESULTADO EN EL TRICEL
       ========================== */

    tricel->headResultados = NULL;
    tricel->totalResultados = 0;

    r1 = (struct Resultado *) malloc(sizeof(struct Resultado));
    if (r1 == NULL) {
        printf("Error de memoria creando resultado.\n");
        return;
    }

    /* Datos de ejemplo coherentes con 2 candidatos */
    r1->totalMesas               = 1;
    r1->totalVotantesRegistrados = 100;
    r1->totalVotantesVotaron     = 80;
    r1->votosValidos             = 75;
    r1->votosBlancos             = 3;
    r1->votosNulos               = 2;
    r1->porcentajeParticipacion  = 80.0f;

    for (i = 0; i < MAX_CANDIDATOS; i++) {
        r1->porcentajeCandidato[i] = 0.0f;
    }

    r1->porcentajeCandidato[0] = 55.0f;  /* c1 */
    r1->porcentajeCandidato[1] = 45.0f;  /* c2 */
    r1->idxGanador             = 0;
    r1->porcentajeGanador      = 55.0f;
    r1->ganador                = c1;

    /* lista circular de resultados en el Tricel */
    r1->sig = r1;     /* un solo nodo, se apunta a si mismo */
    tricel->headResultados = r1;
    tricel->totalResultados = 1;

    /* enlazar la eleccion con su resultado si quieres usar ese campo */
    e1->candidato_En_Resultado = r1;

    printf("Sistema inicializado con datos de ejemplo:\n");
    printf(" - %d candidatos en Servel\n", servel->totalCandidatos);
    printf(" - 1 eleccion (ID=%d) con %d candidatos\n", e1->id, e1->nCands);
    printf(" - 1 mesa (ID=%d) en esa eleccion\n", m1->idMesa);
    printf(" - 1 resultado en Tricel (ganador ID=%d)\n", r1->ganador->id);
    /* ==========================
       5) VOTANTES DE EJEMPLO EN ESA MESA
       ========================== */

    {
        struct DVotante *v1 = NULL;
        struct DVotante *v2 = NULL;
        struct Persona  *p1v = NULL;
        struct Persona  *p2v = NULL;

        /* --- Votante 1 --- */
        v1 = (struct DVotante *) malloc(sizeof(struct DVotante));
        p1v = (struct Persona  *) malloc(sizeof(struct Persona));

        if (v1 == NULL || p1v == NULL) {
            printf("Error de memoria creando votante 1.\n");
        } else {
            v1->datos = p1v;

            p1v->rut[0]          = (char *) malloc(12 * sizeof(char));
            p1v->nombre[0]       = (char *) malloc(50 * sizeof(char));
            p1v->nacionalidad[0] = (char *) malloc(30 * sizeof(char));

            if (p1v->rut[0] != NULL &&
                p1v->nombre[0] != NULL &&
                p1v->nacionalidad[0] != NULL)
            {
                strcpy(p1v->rut[0],          "33333333");
                strcpy(p1v->nombre[0],       "Carlos");
                strcpy(p1v->nacionalidad[0], "chilena");
                p1v->edad = 30;

                v1->habilitado = 1;
                v1->haVotado   = 0;
                v1->idxCandVoto = IDX_SIN_VOTO;
                v1->ant = NULL;
                v1->sig = NULL;

                /* insertar en lista doble de la mesa m1 */
                if (m1->headV == NULL) {
                    m1->headV = v1;
                    m1->tailV = v1;
                } else {
                    v1->ant        = m1->tailV;
                    m1->tailV->sig = v1;
                    m1->tailV      = v1;
                }

                servel->totalVotantesRegistrados++;
            } else {
                printf("Error de memoria en cadenas del votante 1.\n");
            }
        }

        /* --- Votante 2 --- */
        v2 = (struct DVotante *) malloc(sizeof(struct DVotante));
        p2v = (struct Persona  *) malloc(sizeof(struct Persona));

        if (v2 == NULL || p2v == NULL) {
            printf("Error de memoria creando votante 2.\n");
        } else {
            v2->datos = p2v;

            p2v->rut[0]          = (char *) malloc(12 * sizeof(char));
            p2v->nombre[0]       = (char *) malloc(50 * sizeof(char));
            p2v->nacionalidad[0] = (char *) malloc(30 * sizeof(char));

            if (p2v->rut[0] != NULL &&
                p2v->nombre[0] != NULL &&
                p2v->nacionalidad[0] != NULL)
            {
                strcpy(p2v->rut[0],          "44444444");
                strcpy(p2v->nombre[0],       "Daniela");
                strcpy(p2v->nacionalidad[0], "chilena");
                p2v->edad = 28;

                v2->habilitado = 1;
                v2->haVotado   = 0;
                v2->idxCandVoto = IDX_SIN_VOTO;
                v2->ant = NULL;
                v2->sig = NULL;

                /* insertar al final de la lista doble de la mesa m1 */
                if (m1->headV == NULL) {
                    m1->headV = v2;
                    m1->tailV = v2;
                } else {
                    v2->ant        = m1->tailV;
                    m1->tailV->sig = v2;
                    m1->tailV      = v2;
                }

                servel->totalVotantesRegistrados++;
            } else {
                printf("Error de memoria en cadenas del votante 2.\n");
            }
        }

        printf("Se agregaron votantes de ejemplo a la mesa %d.\n", m1->idMesa);
    }
}


// AQUI EMPIEZAN LAS FUNCIONES DEL MENU SERVEL
int validarDatosCanditado(struct Candidato *candidato)
{
    int contadorValidador = 0;

    if (candidato != NULL && candidato->datos != NULL)
    {
        /* 1) Edad mínima 35 años */
        if (candidato->datos->edad >= 35)
        {
            contadorValidador++;
        }
        if (candidato->datos->nacionalidad[0] != NULL && strcmp(candidato->datos->nacionalidad[0], "chilena") == 0)
        {
            contadorValidador++;
        }
        if (candidato->tipo[0] != NULL && strcmp(candidato->tipo[0], "independiente") == 0)
        {
            if (candidato->firmasApoyo > 100000)
            {
                contadorValidador++;
            }
            if (contadorValidador == 3)
            {
                return 1;
            }
            else
            {
                return 0;

            }

        }
        else
        {
            // Aqui ya no es independiente xd, con la edad + su nacionalidad estamo
            if (contadorValidador == 2)
            {
                return 1;

            }
            else
            {
                return 0;

            }
        }

    }
    return 0;
}
int Servel_inicializarCandidato(struct Servel *servel,
                                struct Candidato **Candidato)
{
    struct Candidato *candidato;
    struct Persona   *persona;

    if (servel == NULL || Candidato == NULL) {
        printf("ERROR: puntero NULL en Servel_inicializarCandidato.\n");
        return 0;
    }

    if (servel->totalCandidatos >= MAX_CANDIDATOS) {
        printf("No hay mas espacio para candidatos.\n");
        return 0;
    }

    candidato = (struct Candidato*) malloc(sizeof(struct Candidato));
    if (candidato == NULL) {
        printf("Error de memoria para candidato.\n");
        return 0;
    }

    persona = (struct Persona*) malloc(sizeof(struct Persona));
    if (persona == NULL) {
        printf("Error de memoria para persona.\n");
        return 0;
    }

    candidato->datos = persona;

    /* Reservar SOLO el indice 0 de cada arreglo de punteros */
    persona->rut[0]          = (char*) malloc(12 * sizeof(char));
    persona->nombre[0]       = (char*) malloc(50 * sizeof(char));
    persona->nacionalidad[0] = (char*) malloc(30 * sizeof(char));
    candidato->partido[0]    = (char*) malloc(40 * sizeof(char));
    candidato->tipo[0]       = (char*) malloc(20 * sizeof(char));

    if (persona->rut[0] == NULL ||
        persona->nombre[0] == NULL ||
        persona->nacionalidad[0] == NULL ||
        candidato->partido[0] == NULL ||
        candidato->tipo[0] == NULL) {

        printf("Error de memoria para cadenas del candidato.\n");
        return 0;
        }

    (*Candidato) = candidato;
    return 1;  // Ahi funciona
}
int Servel_cargarDatosCandidato(struct Candidato *candidato)
{
    struct Persona *persona;

    if (candidato == NULL || candidato->datos == NULL) {
        printf("ERROR: candidato o persona NULL en Servel_cargarDatosCandidato.\n");
        return 0;
    }

    persona = candidato->datos;

    printf("Rut (sin puntos, sin guion): ");
    if (scanf("%11s", persona->rut[0]) != 1)
    {
        printf("Rut invalido.\n");
        return 0;
    }

    printf("Nombre: ");
    if (scanf("%49s", persona->nombre[0]) != 1)
    {
        printf("Nombre invalido.\n");
        return 0;
    }

    printf("Nacionalidad: ");
    if (scanf("%29s", persona->nacionalidad[0]) != 1)
    {
        printf("Nacionalidad invalida.\n");
        return 0;
    }

    printf("Edad: ");
    if (scanf("%d", &persona->edad) != 1)
    {
        printf("Edad invalida.\n");
        return 0;
    }

    printf("Partido: ");
    if (scanf("%39s", candidato->partido[0]) != 1)
    {
        printf("Partido invalido.\n");
        return 0;
    }

    printf("Tipo (Partido/Independiente): ");
    if (scanf("%19s", candidato->tipo[0]) != 1)
    {
        printf("Tipo invalido.\n");
        return 0;
    }

    /* Firmas solo si es independiente */
    if (candidato->tipo[0] != NULL &&
        strcmp(candidato->tipo[0], "independiente") == 0) {

        printf("Cantidad de firmas de apoyo: ");
        if (scanf("%d", &candidato->firmasApoyo) != 1) {
            printf("Valor invalido, se consideran 0 firmas.\n");
            candidato->firmasApoyo = 0;
        }
        } else {
            candidato->firmasApoyo = 0;
        }

    return 1;  // todo bien
}

char *txtRonda(int ronda)
{
    switch (ronda) {
        case RONDA_PRIMERA:  return "PRIMERA";
        case RONDA_SEGUNDA:  return "SEGUNDA";
        default:             return "DESCONOCIDA";
    }
}

char *txtEstado(int estado)
{
    switch (estado) {
        case ELEC_ABIERTA:    return "ABIERTA";
        case ELEC_CERRADA:    return "CERRADA";
        case ELEC_PROCLAMADA: return "PROCLAMADA";
        default:              return "DESCONOCIDO";
    }
}
struct Eleccion *buscarEleccionPorId(struct Servel * servel, int id)
{
    struct Eleccion *eleccionact;
    if (servel->elecciones != NULL)
    {
        eleccionact = servel->elecciones;
        while (eleccionact != NULL)
        {
            if (eleccionact->id == id)
            {
                return eleccionact;

            }
            eleccionact = eleccionact->sig;

        }
        return NULL;
    }
    return NULL;
}

void CambiarEstadoDeEleccion(struct Servel * servel)
{
    int idElec, newEstado;
    struct Eleccion * eleccion;
    int verificador = 1; // 1 si esta bien , 0 si no lo está
    if (servel == NULL)
    {
        printf("Servel NUll");
        verificador = 0;
    }
    // pedir Id de la Eleccion
    if (verificador == 1)
    {
        printf("Id de la eleccion a modificar: ");
        if (scanf("%d", &idElec) != 1)
        {
            printf("Id invalido.\n");
            verificador = 0;

        }

    }
    if (verificador == 1)
    {
        eleccion = buscarEleccionPorId(servel, idElec);
        if (eleccion == NULL)
        {
            printf("ELECCION NUll");
            verificador = 0;

        }
        // mostrar el estado actual y solicitar el nuevo estado
        if (verificador == 1)
        {
            printf("El estado actual de la Eleccion %d: %s\n", idElec, txtEstado(eleccion->estado));

            printf("Nuevo estado a elegir ( 1 = ABIERTA , 2 = CERRADA , 3 = PROCLAMADA):  ");
            if (scanf("%d", &newEstado) != 1)
            {
                printf("Entrada invalida.\n");
                verificador = 0;

            }
            else if (newEstado != ELEC_ABIERTA && newEstado != ELEC_CERRADA && newEstado != ELEC_PROCLAMADA)
            {
                printf("Estado de eleccion invalido ( usa 1, 2 ,3)\n");
                verificador = 0;

            }
            // aplicamos el cambio
            if (verificador == 1)
            {
                eleccion->estado = newEstado;
                printf("ELECCION %d ahora esta en estado: %s\n", eleccion->id, txtEstado(eleccion->estado));


            }

        }


    }
}
// terminan las funciones de servel

// Aqui empieza menu servel
void menuServel(struct Servel *servel)
{
    int indice = -1;
    int c; /* para limpiar el buffer cuando haya error de entrada */

    do
    {
        printf("\n-- SERVEL --\n");
        printf("1) Agregar candidato + validar candidato \n");
        printf("2) Listar candidatos \n");
        printf("3) Crear ELECCION (agregar al historial)\n");
        printf("4) Listar ELECCIONES\n");
        printf("5) Eliminar ELECCION\n");
        printf("6) Cambiar el estado de la Eleccion\n");
        printf("0) Volver\n");
        printf("Opcion: ");

        if (scanf("%d", &indice) != 1) {
            printf("Entrada invalida.\n");
            /* limpiar el resto de la linea para que no quede basura en el buffer */
            while ((c = getchar()) != '\n' && c != EOF) { }
            indice = -1;
            continue;
        }

        switch (indice)
        {

            case 1:
            {
                struct Candidato *candidato = NULL;
                int ok;
                // este ok valida bien que se cumplan los requerimientos
                /* 1) Reservar estructuras y cadenas */
                ok = Servel_inicializarCandidato(servel, &candidato);
                if (ok == 0) {
                    /* ya se imprimieron los mensajes de error dentro */
                    break;
                }

                /* 2) Leer datos desde teclado */
                ok = Servel_cargarDatosCandidato(candidato);
                if (!ok) {
                    printf("No se pudo completar el registro del candidato.\n");
                    break;
                }

                /* 3) Asignar id y guardar en el Servel */
                candidato->id = servel->totalCandidatos;
                servel->candidatos[servel->totalCandidatos] = candidato;
                servel->totalCandidatos++;

                /* 4) Validar */
                candidato->esValido = validarDatosCanditado(candidato);

                if (candidato->esValido == 1)
                {
                    printf("Candidato agregado con id %d y MARCADO como VALIDO.\n",
                           candidato->id);
                }
                else
                {
                    printf("Candidato agregado con id %d, pero NO cumple los requisitos (esValido=0).\n", candidato->id);
                }

                break;
            }
                /* ===== CASE 2: LISTAR CANDIDATOS ===== */
            case 2:
            {
                int i;
                struct Candidato *candidato;
                if (servel->totalCandidatos == 0) {
                    printf("No hay candidatos en el pool.\n");
                    break;
                }
                for (i = 0; i < servel->totalCandidatos; ++i) {
                    candidato = servel->candidatos[i];
                    if (candidato == NULL )
                    {
                        printf("Error en la lista de candidatos.\n");

                    }
                    else
                    {
                        printf("[%d] ID=%d | RUT=%s | Nombre=%s | Nac=%s | Edad=%d | Tipo=%s | Partido=%s | Firmas=%d | Valido=%d\n",
                           i,
                           candidato->id,
                           candidato->datos->rut[0],
                           candidato->datos->nombre[0],
                           candidato->datos->nacionalidad[0],
                           candidato->datos->edad,
                           candidato->tipo[0],
                           candidato->partido[0],
                           candidato->firmasApoyo,
                           candidato->esValido);

                    }
                }
                break;
            }
            case 3:
            { /* Crear ELECCION (agregar al historial) */
                int idElec, ronda, i;
                struct Eleccion *aux;
                struct Eleccion *nueva;
                /* pedir datos */
                printf("ID eleccion: ");
                if (scanf("%d", &idElec) != 1) {
                    printf("ID invalido.\n");
                    break;
                }

                printf("Ronda (1=primera, 2=segunda): ");
                if (scanf("%d", &ronda) != 1 || (ronda != 1 && ronda != 2)) {
                    printf("Ronda invalida (usa 1 o 2).\n");
                    break;
                }

                /* evitar ID duplicado */
                aux = servel->elecciones;
                while (aux != NULL) {
                    if (aux->id == idElec) {
                        printf("Ya existe una eleccion con ese id %d.\n", idElec);
                        break;
                    }
                    aux = aux->sig;
                }
                if (aux != NULL) break; /* ya existía */

                /* reservar nodo eleccion */
                {
                    nueva = (struct Eleccion*) malloc(sizeof(struct Eleccion));
                    if (nueva == NULL)
                    {
                        printf("Error de memoria para eleccion.\n");
                        break;
                    }

                    /* inicializar */
                    nueva->id      = idElec;
                    nueva->ronda   = ronda;            /* 1 o 2 */
                    nueva->estado  = ELEC_ABIERTA;
                    nueva->nCands  = 0;
                    for (i = 0; i < MAX_CANDIDATOS; ++i)
                        nueva->cands[i] = NULL;

                    nueva->arbolMesas = NULL;
                    nueva->sig = NULL;
                    // insertar al inicio del historial
                    nueva->sig = servel->elecciones;
                    servel->elecciones = nueva;

                    printf("Eleccion creada: id=%d, ronda=%d, estado=ABIERTO, nCands=%d\n",nueva->id, nueva->ronda, nueva->nCands);
                }
                break;
            }
            case 4: { /* Listar ELECCIONES */
                struct Eleccion *eleccion;
                int idx = 0 , i;
                int nMesas;

                if (servel->elecciones == NULL) {
                    printf("No hay elecciones en el historial.\n");
                    break;
                }

                eleccion = servel->elecciones;
                while (eleccion != NULL)
                {

                    printf("#%d -> ID=%d | Ronda=%s | Estado=%s | nCands=%d \n",
                           idx,
                           eleccion->id,
                           txtRonda(eleccion->ronda),
                           txtEstado(eleccion->estado),
                           eleccion->nCands);

                    eleccion = eleccion->sig;
                    idx++;
                }
                break;
            }
                // Eliminar ELECCION por ID (desenlazar )
            case 5:
            {
                int id;
                struct Eleccion *eleccionAnterior = NULL;
                struct Eleccion *eleccionActual  = servel->elecciones;

                printf("ID de la ELECCION a eliminar: ");
                if (scanf("%d", &id) != 1) {
                    printf("ID invalido.\n");
                    break;
                }

                /* buscar nodo por id */
                while (eleccionActual != NULL)
                {
                    if (eleccionActual->id == id)
                        break;
                    eleccionAnterior = eleccionActual;
                    eleccionActual  = eleccionActual->sig;
                }

                if (eleccionActual == NULL) {
                    printf("No existe eleccion con id %d.\n", id);
                    break;
                }

                /* desenlazar del historial (lista simple) */
                if (eleccionAnterior == NULL) {
                    /* eliminando cabeza */
                    servel->elecciones = eleccionActual->sig;
                }
                else
                {
                    eleccionAnterior->sig = eleccionActual->sig;
                }
                printf("Eleccion %d eliminada del historial \n", id);
                break;
            }
            case 6:
            {
                CambiarEstadoDeEleccion(servel);
                break;

            }
            case 0:
                printf("Volviendo al menu principal...\n");
                break;
            default:
                printf("Opcion invalida en Servel.\n");
                break;
        }
    } while (indice != 0);
}
// AQUI TERMINA SERVEL , ORDEN XFA


// funciones menu tricel amen ↓
void ContarMesas(struct NodoMesa *mesas, int *contador){
    if (mesas){
        ContarMesas(mesas->izq, contador);
        (*contador)++;
        ContarMesas(mesas->der, contador);
    }

}

void ContarVotosEmitidos(struct NodoMesa *mesas, int *contadorVotos){
    if (mesas){
        ContarVotosEmitidos(mesas->izq, contadorVotos);
        (*contadorVotos)+= mesas->totalVotosEmitidos;
        ContarVotosEmitidos(mesas->der, contadorVotos);
    }

}

void ContarVotosNulos(struct NodoMesa *mesas, int *contadorNulos){
    if (mesas){
        ContarVotosNulos(mesas->izq, contadorNulos);
        (*contadorNulos)+= mesas->votosNulos;
        ContarVotosNulos(mesas->der, contadorNulos);
    }
}

void ContarVotosBlancos(struct NodoMesa *mesas, int *contadorBlancos){
    if (mesas){
        ContarVotosBlancos(mesas->izq, contadorBlancos);
        (*contadorBlancos)+= mesas->votosBlancos;
        ContarVotosBlancos(mesas->der, contadorBlancos);
    }
}

void ContarXcandidato(struct NodoMesa *mesas, int idCandidato, int *cantidadXcandidato){
    if (mesas){
        ContarXcandidato(mesas->izq, idCandidato, cantidadXcandidato);

        (*cantidadXcandidato) += mesas->votosCandidatos[idCandidato];

        ContarXcandidato(mesas->der, idCandidato, cantidadXcandidato);
    }
}


int ValidarSegundaVuelta(struct Resultado *resultados, struct Eleccion *eleccionActual){   //valida
    int i;
    for (i = 0; i < eleccionActual->nCands; i++){
        if(resultados->porcentajeCandidato[i] > 50.00){
            resultados->ganador = eleccionActual->cands[i];
            resultados->idxGanador = i;
            resultados->porcentajeGanador=resultados->porcentajeCandidato[i];
            return 0;
        } ;
    }

    return 1;
}



void mostrarResultados(struct Resultado *resultados, struct Eleccion *eleccion)
{
    if (eleccion == NULL) {
        printf("ERROR: No se encontró la elección asociada a este resultado.\n");
        return;
    }

    printf("ID de la eleccion = %d\n", eleccion->id);
    printf("Ronda = %s\n", eleccion->ronda == RONDA_PRIMERA ? "Primera vuelta" : "Segunda vuelta");

    printf("total de mesas = %d\n", resultados->totalMesas);
    printf("total de votantes registrados = %d\n", resultados->totalVotantesRegistrados);
    printf("total de votos = %d\n", resultados->totalVotantesVotaron);
    printf("total de votos nulos = %d\n", resultados->votosNulos);
    printf("total de votos blancos = %d\n", resultados->votosBlancos);
    printf("total de votos efectivos = %d\n\n", resultados->votosValidos);

    if (resultados->idxGanador != -1 && resultados->ganador != NULL)
    {
        printf("situacion de elecciones = Un candidato superó el 50%%, elecciones terminadas.\n\n");
        printf("GANADOR ELECCION\n");
        printf("ID DEL GANADOR = %d\n", resultados->ganador->id);
        printf("NOMBRE DEL GANADOR = %s\n", resultados->ganador->datos->nombre[0]);
        printf("PORCENTAJE DEL GANADOR = %.2f%%\n\n", resultados->porcentajeGanador);
    }
    else
    {
        printf("situacion de elecciones = Ningún candidato superó el 50%%.\n");
        printf("Se realizará una segunda vuelta.\n\n");
    }
}






void paraSegundaVuelta(struct Resultado *resultados, struct Eleccion *sistema, int *idX, int *idY){
    float por1 = -1.0f,por2 = -1.0f;
    int i;
    for (i = 0;i < sistema->nCands; i++){

        if(resultados->porcentajeCandidato[i] > por1){
            por2 = por1;
            *idY =*idX;



            por1 = resultados->porcentajeCandidato[i];
            *idX = i;
        }

        else if (resultados->porcentajeCandidato[i] > por2){
            por2 =  resultados->porcentajeCandidato[i];
            *idY = i;
        }
    }

}


struct Resultado* recopilarResultados(struct SistemaElectoral *sistema,struct Eleccion *eleccionActual){
    if (sistema->servel->totalVotantesRegistrados == 0) return NULL;

    int mesasTotales = 0, votosEmitidos = 0, TvotosBlancos = 0, TvotosNulos = 0, segunda_vuelta = 0, j;
    int i;

    int votosCandidato[MAX_CANDIDATOS] = {0};
    struct Resultado *final = malloc(sizeof(struct Resultado));
    final->ganador = NULL;
    final->idxGanador = -1;
    final->porcentajeGanador = 0.0f;
    final->sig = NULL;


    for (j = 0; j< MAX_CANDIDATOS; j++){
        final->porcentajeCandidato[j]=0.0f;
    }



    float participacion = 0.0f;

    ContarMesas(eleccionActual->arbolMesas, &mesasTotales);
    ContarVotosEmitidos(eleccionActual->arbolMesas, &votosEmitidos);
    ContarVotosNulos(eleccionActual->arbolMesas, &TvotosNulos);
    ContarVotosBlancos(eleccionActual->arbolMesas, &TvotosBlancos);


    eleccionActual->candidato_En_Resultado = final;
    final->totalMesas = mesasTotales;
    final->totalVotantesRegistrados = sistema->servel->totalVotantesRegistrados;
    final->totalVotantesVotaron = votosEmitidos;
    final->votosBlancos = TvotosBlancos;
    final->votosNulos = TvotosNulos;
    final->votosValidos = votosEmitidos - TvotosBlancos - TvotosNulos;


    if (final->totalVotantesRegistrados > 0){
        participacion =((float)votosEmitidos / (float)sistema->servel->totalVotantesRegistrados) * 100.0f;
        final->porcentajeParticipacion = participacion;
    }
    else{
        final->porcentajeParticipacion = 0.0;
    }



    for (i = 0; i < eleccionActual->nCands; i++) {

        ContarXcandidato(eleccionActual->arbolMesas, i, &votosCandidato[i]);

        if (votosEmitidos > 0) {
            final->porcentajeCandidato[i] =((float)votosCandidato[i] * 100.0f) / (float)final->votosValidos;
        }
        else {
            final->porcentajeCandidato[i] = 0.0f;
        }
    }

    segunda_vuelta = ValidarSegundaVuelta(final,eleccionActual);

    if (eleccionActual->ronda == RONDA_PRIMERA && segunda_vuelta == 1){
        printf("situacion de elecciones = No hay candidatos que superen el 50%% de votos, habrá una segunda vuelta.\n\n");

        int idX =-1, idY=-1, k;
        paraSegundaVuelta(final,eleccionActual,&idX, &idY);

        struct Eleccion *segunda = malloc(sizeof(struct Eleccion));
        memset(segunda, 0, sizeof(struct Eleccion)); //PARA INICIALIZAR TODO EN 0 o NULL;

        segunda->candidato_En_Resultado = NULL;
        segunda->sig = NULL;
        segunda->nCands = 2;

        segunda->cands[0]=eleccionActual->cands[idX];
        segunda->cands[1]=eleccionActual->cands[idY];

        segunda->arbolMesas = eleccionActual->arbolMesas;
        segunda->id = eleccionActual->id + 1000;

        segunda->sig = sistema->servel->elecciones;
        sistema->servel->elecciones = segunda;

        printf("SEGUNDA VUELTA CREADA (ID = %d)\n", segunda->id);
        printf("Candidatos que pasan: %s y %s\n\n",segunda->cands[0]->datos->nombre[0],segunda->cands[1]->datos->nombre[0]);


        return final;

    }


    printf("HAY UN GANADOR, ELECCIONES TERMINADAS\n\n");
    return final;
}




void  agregarAtricel(struct Tricel * tricel, struct Resultado *resultadoNuevo){
    if (tricel->headResultados == NULL) {
        tricel->headResultados = resultadoNuevo;
        resultadoNuevo->sig = resultadoNuevo;
        return;
    }

    struct Resultado *aux = tricel->headResultados;

    do{
        aux=aux->sig;
    }while(aux->sig !=tricel->headResultados);

    aux->sig = resultadoNuevo;
    resultadoNuevo->sig = tricel->headResultados;
}






struct Eleccion * buscarEleccionPorResultado(struct Servel *servel, struct Resultado *r){
    struct Eleccion *aux = servel->elecciones;

    while (aux != NULL) {
        if (aux->candidato_En_Resultado == r) {
            return aux;
        }
        aux = aux->sig;
    }

    return NULL;
}



void resultadoEleccionXid (struct Tricel *sistema, struct Servel *servel,int idBuscado){
    if (sistema->headResultados == NULL){
        printf("no hay resultados registrados en el sistema\n");
        return;
    }

    struct Resultado *cabeza = sistema->headResultados;
    struct Resultado *recorrido = sistema->headResultados;

    do {

        struct Eleccion *elec = buscarEleccionPorResultado(servel, recorrido);

        if (elec && elec->id == idBuscado){
            mostrarResultados(recorrido,elec);
            return;
        }
        recorrido = recorrido->sig;

    }while(recorrido!= cabeza);

    printf("No existen resultados referente a la id recibida (%d)\n",idBuscado);

}




void proclamarUnGanador (struct Tricel *tricel)
{
    if (tricel->headResultados == NULL){
        printf("NO HAY RESULTADOS REGISTRADOS\n\n");
        return;
    }

    struct Resultado *head = tricel->headResultados;
    struct Resultado *rec = head;

    do {
        rec = rec->sig;
    } while (rec->sig != head);

    printf("GANADOR ELECCION DE LAS ULTIMAS ELECCIONES REALIZADAS\n\n");
    printf("ID DEL GANADOR = %d\n", rec->ganador->id);
    printf("NOMBRE DEL GANADOR = %s\n", rec->ganador->datos->nombre[0]);
    printf("PORCENTAJE DEL GANADOR = %f\n\n", rec->porcentajeGanador);
}
void listarResultado (struct Tricel *tricel, struct Servel *servel){

    if (tricel->headResultados == NULL){
        printf("NO HAY RESULTADOS EN EL REGISTRO\n\n");
        return;
    }

    printf("LISTA DE RESULTADOS REGISTRADOS EN EL TRICEL\n\n");

    struct Resultado *rec = tricel->headResultados;

    do{

        struct Eleccion *elec = buscarEleccionPorResultado(servel, rec);

        mostrarResultados(rec,elec);
        rec=rec->sig;
    }while(rec!=tricel->headResultados);

    printf("\n\n");

    printf("resultados listados\n\n");


}
//funciones tricel fin

// menu tricel
void MenuTricel( struct Tricel *tricel, struct SistemaElectoral *sistema)
{
    int indice = - 1;

    do
    {
        printf("\n-- TRICEL --\n");
        printf("1) Generar resultados desde Eleccion\n"); // -> (Esto acumula ABB de mesas)
        printf("2) Listar Resultados\n" );
        printf("3) Ver resultado por Id de ELECCION\n");
        printf("4) Proclamar Ganador\n");
        if (scanf("%d", &indice) != 1)
        {
            indice = - 1;
            continue;

        }
        switch (indice)
        {
            case 1:
            {
                int idB;
                printf("Ingrese id de la eleccion a buscar\n\n");
                scanf("%d",&idB);

                struct Eleccion *aux =sistema->servel->elecciones;

                while (aux != NULL && aux->id != idB){
                    aux = aux->sig;
                }

                if (aux == NULL){
                    printf("No existe una elección con ese ID.\n");
                    break;
                }

                //generarVotosAleatorios(aux->arbolMesas, aux->nCands); ///esto lo puedes borrar, es para votos aleatorios

                struct Resultado *resultado = recopilarResultados(sistema, aux);

                agregarAtricel(tricel, resultado);


                printf("Generar Resultado, aun no \n");
                break;
            }
            case 2:
            {

                listarResultado(tricel, sistema->servel);
                printf("Listar Resultados, aun no  \n");
                break;

            }
            case 3:
            {
                int idB;
                printf("Ver resultado por id\n");
                printf("Ingrese el ID de la eleccion que desee buscar\n\n");
                scanf("%d",&idB);
                resultadoEleccionXid(tricel, sistema->servel, idB);
                break;

            }
            case 4:
            {
                proclamarUnGanador(tricel);
                printf("Ganador proclamado\n");
                break;

            }
            case 0:
            {
                printf("BREAK");
                break;

            }
        }


    }while (indice != 0);

}

//FUNCIONES DE MENU VOTANTES
struct NodoMesa * buscarLaMesaConId(struct NodoMesa * raiz , int idBuscado)
{
    if (raiz == NULL)
    {
        //ehhh no creo q deba explicar esto xddd, si es null ,retorno null
        return NULL;

    }
    if (idBuscado < raiz->idMesa)
    {
        // busco en el hijito izquierdo
        return buscarLaMesaConId(raiz->izq , idBuscado);

    }
    else if (idBuscado > raiz->idMesa)
    {
        //buscamos en el derechooooo
        return buscarLaMesaConId(raiz->der , idBuscado);

    }
    else
    {
        // aqui la encontramos
        return raiz;
    }

}

void RegistrarVotanteEnMesa(struct Servel * servel)
{
    int ideleccion, idmesa;
    struct Eleccion *eleccion;
    struct NodoMesa *mesa;
    struct DVotante *votante;
    struct Persona *persona;
    int validador = 1; // Con 1 asumimos q todo va super bien , si algo falla le asignamos el 0 yerra
    if (servel == NULL)
    {
        printf("ERROR: Servel NULL.\n");
        validador = 0;
    }
    else
    {
        printf("Id de la eleccion: ");
        if (scanf("%d", &ideleccion) != 1)
        {
            printf("ID invalido.\n");
            validador = 0;

        }
        if (validador == 1)
        {
            eleccion = buscarEleccionPorId(servel, ideleccion);
            if (eleccion == NULL)
            {
                printf("No existe eleccion con id %d.\n", ideleccion);
                validador = 0;

            }
        }
        if (validador == 1)
        {
            printf("ID de la Mesa: ");
            if (scanf("%d", &idmesa) != 1)
            {
                printf("ID de mesa invalido.\n");
                validador = 0;

            }

        }
        if (validador == 1)
        {
            mesa = buscarLaMesaConId(eleccion->arbolMesas, idmesa);
            if (mesa == NULL)
            {
                printf("No existe mesa con id %d.\n", idmesa);
                validador = 0;
            }

        }
        // los datos xd
        if (validador == 1)
        {
            votante = (struct DVotante *)malloc(sizeof(struct DVotante));
            if (votante == NULL)
            {
                printf("Error al crear memoria.\n");
                validador = 0;

            }

        }
        if (validador == 1)
        {
            persona = (struct Persona *)malloc(sizeof(struct Persona));
            if (persona == NULL)
            {
                printf("Error al crear memoria.\n");
                validador = 0;

            }

        }
        if (validador == 1)
        {
            votante->datos = persona;
            persona->rut[0]          = (char *) malloc(12 * sizeof(char));
            persona->nombre[0]       = (char *) malloc(50 * sizeof(char));
            persona->nacionalidad[0] = (char *) malloc(30 * sizeof(char));
            if (persona->nombre[0] == NULL || persona->nombre[0] == NULL || persona->nacionalidad[0] == NULL)
            {
                printf("Error al crear memoria.\n");
                validador = 0;

            }
        }
        // Lectura de los datos si todo salio bien :)

        if (validador == 1)
        {
            printf("Rut del Votante , sin puntitos ni guion): ");
            if (scanf("%11s", persona->rut[0]) != 1)
            {
                printf("Rut inv\n");
                validador = 0;

            }

        }
        if (validador == 1)
        {
            printf("Nombre del votante: ");
            if (scanf("%49s", persona->nombre[0]) != 1)
            {
                printf("Nombre inv\n");
                validador = 0;

            }

        }
        if (validador == 1)
        {
            printf("Nacionalidad del votante: ");

            if (scanf("%29s" , persona->nacionalidad[0])!= 1)
            {
                printf("Nacionalidad inv\n");
                validador = 0;
            }
        }
        // si todo se cumplio , configuramos los campos del votante y los insertamos
        if (validador == 1)
        {
            votante->habilitado = 1;
            votante->haVotado = 0;
            votante->idxCandVoto = IDX_SIN_VOTO;
            votante->ant = NULL;
            votante->sig = NULL;
            if (mesa->headV == NULL)
            {
                mesa->headV = votante;
                mesa->tailV = votante;

            }
            else
            {
                votante->ant = mesa->tailV;
                mesa->tailV->sig = votante;
                mesa->tailV = votante;

            }
            servel->totalVotantesRegistrados++;
            printf("Votante Rut = %s , registrado en Eleccion %d , Mesa %d.\n",persona->rut[0], eleccion->id, mesa->idMesa);

        }
        else
        {
            printf("No se pudo registrar votante por erroes abc\n");

        }
    }
    return;

}
void ListarVotantesDeMesa(struct Servel *servel) {
    int idEleccion, idMesa;
    struct Eleccion *eleccion;
    struct NodoMesa *mesa;
    struct DVotante * votante;
    int verificador = 1;
    if (servel == NULL)
    {
        printf("ERROR: Servel NULL en menuVotantes.\n");
        verificador = 0;
    }
    // pedimos el id del la eleccion
    if (verificador == 1)
    {
        printf("Id de la eleccion: ");
        if (scanf("%d", &idEleccion) != 1)
        {
            printf("Entrada inv\n");
            verificador = 0;

        }

    }
    // 2 buscar eleccion por Id
    if (verificador == 1)
    {
        eleccion = buscarEleccionPorId(servel, idEleccion);
        if (eleccion == NULL)
        {
            printf("No existe esa Eleccion.\n");
            verificador = 0;


        }
    }
    // 3 Pedir Id de la Mesa
    if (verificador == 1)
    {
        printf("Id de la Mesa: ");
        if (scanf("%d", &idMesa) != 1)
        {
            printf("Entrada inv\n");
            verificador = 0;

        }

    }
    // 4 Buscar la mesa en el Abb de esa eleccion
    if (verificador == 1)
    {
        mesa = buscarLaMesaConId(eleccion->arbolMesas, idMesa);
        if (mesa == NULL)
        {
            printf("No existe esa Mesa.\n");
            verificador = 0;

        }

    }
    // 5 ver si la mesa tiene votantes
    if (verificador == 1)
    {
        if (mesa->headV == NULL)
        {
            printf("Esa Mesa No tiene votantes registrados.\n");
            verificador = 0;
        }

    }
    // 6 Recorrer la lista doblemente enlzada blabla y mostrarlos po q ma
    if (verificador == 1)
    {
        printf("\n--- Votantes de Eleccion %d , Mesa %d ---\n", eleccion->id, mesa->idMesa);
        votante = mesa->headV;
        while (votante != NULL)
        {
            if (votante->datos != NULL)
            {
                printf("RUT=%s | Nombre=%s | Nac=%s | Edad=%d | habilitado=%d | haVotado=%d | idxCandVoto=%d\n",
                           votante->datos->rut[0],
                           votante->datos->nombre[0],
                           votante->datos->nacionalidad[0],
                           votante->datos->edad,
                           votante->habilitado,
                           votante->haVotado,
                           votante->idxCandVoto);

            }
            votante = votante->sig;

        }
    }

}


// AQUI EMPIEZA MENU VOTANTES
void menuVotante(struct Servel *servel)
{
    int opcion = -1;
    int c;

    if (servel == NULL) {
        printf("ERROR: Servel NULL en menuVotantes.\n");
        return;
    }

    do {
        printf("\n-- VOTANTES --\n");
        printf("1) Registrar votante en una mesa\n");
        printf("2) Listar votantes de una mesa\n");
        printf("0) Volver\n");
        printf("Opcion: ");

        if (scanf("%d", &opcion) != 1) {
            printf("Entrada invalida.\n");
            opcion = -1;
            while ((c = getchar()) != '\n' && c != EOF) { }
            continue;
        }

        switch (opcion) {
            case 1:
                RegistrarVotanteEnMesa(servel);
                break;

            case 2:

                ListarVotantesDeMesa(servel);
                break;

            case 0:
                printf("Volviendo al menu principal...\n");
                break;

            default:
                printf("Opcion invalida en Votantes.\n");
                break;
        }

    } while (opcion != 0);
}
// aqui termina menu votantes


int main(void)
{
    struct SistemaElectoral *sistema;
    int Eleccion_Usuario = -1;
    int tipoUsuario = 0;
    sistema = (struct SistemaElectoral *)malloc(sizeof( struct SistemaElectoral));
    if (sistema == NULL)
    {
        printf("ERROR AWNAOOOO.\n");
        return 1;

    }
    sistema->servel = (struct Servel *)malloc(sizeof(struct Servel));
    sistema->tricel = (struct Tricel *)malloc(sizeof(struct Tricel));

    if (sistema->tricel == NULL || sistema->servel == NULL)
    {
        printf("ERROR AL CREAR EL TRICEL/SERVEL\n");
        return 1;
    }
    // AQUI EMPIEZA EL SERVEL
    sistema->servel->totalCandidatos = 0;
    sistema->servel->elecciones = NULL;
    sistema->servel->totalVotantesRegistrados = 0;
    // AQUI EMPIEZA EL TRICEL
    sistema->tricel->headResultados = NULL;
    sistema->tricel->totalResultados = 0;
    inicializarSistemaConDatos(sistema);

    // Seleccionar el tipo de usuario
    do
    {
        printf("\n===  Seleccione el Usuario ===\n");
        // El admin tiene acceso a todo lo disponible en el codigo
        printf("1) Admin\n");
        // El trabajador del servel tiene acceso al menu servel y al menu de los votatnes
        printf("2) Trabajador del servel\n");
        // EL Trabajador del Tricel tiene acceso al tricel y al menu de reportes
        printf("3) Trabajador del Tricel\n");
        if (scanf("%d", &tipoUsuario) != 1)
        {
            printf("Entrada invalida.\n");
            tipoUsuario = 0;
            continue;

        }
        if (tipoUsuario < 1 || tipoUsuario > 3)
        {
            printf("Tipo de usuario invalido , es solo 1 , 2 o 3 \n");
            tipoUsuario = 0;

        }

    }while (tipoUsuario == 0);

    // Menu principal segun rol
    do
    {
        // admin
        if (tipoUsuario == 1)
        {
            printf("\nSistema Principal\n");
            printf("Seleccione\n");
            printf("0) Salir\n");
            printf("1) Servel\n");
            printf("2) Tricel\n");
            printf("3) Votantes\n");
            printf("4) Reportes\n");
            printf("Opcion: ");

        }
        else if (tipoUsuario == 2)
        {
            printf("\n=== Sistema para Trabajadpr de Servel ===\n");
            printf("0) Salir\n");
            printf("1) Servel\n");
            printf("2) Votantes\n");

        }
        else if (tipoUsuario == 3)
        {
            printf("\n=== Sistema Para Trabajador de Tricel ===\n");
            printf("0) Salir\n");
            printf("1) Tricel\n");

        }

        if (scanf("%d", &Eleccion_Usuario) != 1) {
            printf("Entrada invalida.\n");
            Eleccion_Usuario = -1;
            continue;
        }
        // admin
        if (tipoUsuario == 1)
        {
            switch (Eleccion_Usuario)
            {
                case 1:
                    menuServel(sistema->servel);
                    break;
                case 2:
                    MenuTricel(sistema->tricel, sistema);
                    break;

                case 3:
                    menuVotante(sistema->servel);
                    break;
                case 4:
                    //MenuReportes(sistema->servel,sistema->tricel);
                    break;

                case 0:
                    printf("Saliendo...\n");
                    break;
                default:
                    printf("Opcion invalida.\n");
                    break;
            }
        }
        else if (tipoUsuario == 2)
        {
            switch (Eleccion_Usuario)
            {
                case 1:
                    menuServel(sistema->servel);
                    break;
                case 2:
                    menuVotante(sistema->servel);
                    break;
                case 0:
                    printf("Saliendo...\n");
                    break;
                default:
                    printf("Opcion invalida.\n");
                    break;

            }
        }
        else if (tipoUsuario == 3)
        {
            switch (Eleccion_Usuario)
            {
                case 1:
                    MenuTricel(sistema->tricel, sistema);
                    break;
                case 0:
                    printf("Saliendo...\n");
                    break;
                default:
                    printf("Opcion invalida.\n");
                    break;
            }

        }


    } while (Eleccion_Usuario != 0);

    return 0;
}
